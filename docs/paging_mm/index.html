<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Memory and Paging · hhuOS</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;introduction&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#introduction&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Introduction&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Memory and Paging · hhuOS"/><meta property="og:type" content="website"/><meta property="og:url" content="https://hhuOS.github.io/index.html"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;introduction&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#introduction&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Introduction&lt;/h2&gt;
"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://hhuOS.github.io/blog/atom.xml" title="hhuOS Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://hhuOS.github.io/blog/feed.xml" title="hhuOS Blog RSS Feed"/><link rel="stylesheet" href="/css/code-blocks-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-blocks-buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo_v3_light.svg" alt="hhuOS"/><h2 class="headerTitleWithLogo">hhuOS</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/doc_overview" target="_self">Documentation</a></li><li class=""><a href="/osguide" target="_self">Videos</a></li><li class=""><a href="/docs/todos" target="_self">TODOs</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="/developers" target="_self">Team</a></li><li class=""><a href="/help" target="_self">Help</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Memory Managment and Paging</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Overview</h3><ul><li class="navListItem"><a class="navItem" href="/docs/doc_overview">Overview</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Memory Managment and Paging</h3><ul><li class="navListItem navListItemActive"><a class="navItem" href="/docs/paging_mm">Memory and Paging</a></li><li class="navListItem"><a class="navItem" href="/docs/bios_call">Bios Call</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Processes and Threads</h3><ul><li class="navListItem"><a class="navItem" href="/docs/process_thread_overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/scheduler">Scheduler</a></li><li class="navListItem"><a class="navItem" href="/docs/process">Process</a></li><li class="navListItem"><a class="navItem" href="/docs/thread">Thread</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Filesystem</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fs_overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fat">FAT</a></li><li class="navListItem"><a class="navItem" href="/docs/vfs">VFS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Components</h3><ul><li class="navListItem"><a class="navItem" href="/docs/modules">Modules</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">GUI</h3><ul><li class="navListItem"><a class="navItem" href="/docs/gui_overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/vesa">VESA</a></li><li class="navListItem"><a class="navItem" href="/docs/color">Color</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Memory and Paging</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2>
<p>hhuOS makes use of Paging (which is available on all modern x86-CPUs) to abstract virtual memory from the physical memory installed in the system. Since hhuOS is only 32-bit compatible at the current state of development, a total virtual memory of 4GB is available for the system. In this section we will describe how the virtual memory in hhuOS is divided into different parts, which memory managers take care for the different memory sections and how the paging system is integrated into the operating system.</p>
<h2><a class="anchor" aria-hidden="true" id="the-virtual-memory-layout-in-hhuos"></a><a href="#the-virtual-memory-layout-in-hhuos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Virtual Memory Layout in hhuOS</h2>
<p>The 4 GB of virtual memory are divided into a Userspace-section and a Kernelspace section at the 3 GB (at <code>0xC0000000</code>). In future versions of hhuOS, each process works in his own address space (which is guaranteed through paging) and is able to use the whole memory below 3 GB. In contrast, everything above 3 GB belongs to the kernel and is mapped into every process`s address space. Since the Userspace memory layout is not implemented yet, lets take a closer look at the structure of the Kernelspace-memory. The 1 GB Kernelspace-memory are divided as follows:</p>
<ul>
<li><code>0xC0000000 - 0xC040000</code>: This part of the memory is mapped to <code>0x0 - 0x40000</code>, e.g. the first 4 MB in physical memory. This identity mapping is very important, because the whole Kernel-code is placed at 1 MB physically and the system´s entry point into the code is defined at <code>0xC0100000</code>. The startup-stack for the kernel is located in this area and grows downwards towards the Kernel-code.</li>
<li><code>0xC0400000 - 0xDF400000</code>: Around 500 MB a reserved for the Kernel-heap. This heap is used in Kernel-mode and managed by a list-based <code>HeapMemoryManager</code>. It is important to note that this heap is only used by the Kernel and is mapped into every address space that is created. The Userspace-heap gets its own <code>HeapMemoryManager</code> for each address space. Only the first 4 MB of this heap are mapped to <code>0x40000 - 0x80000</code> in physical memory to bootstrap the whole system (for more information about this please refer the corresponding section in this documentation).</li>
<li><code>0xDF400000 - 0xEEE00000</code>: This part of memory is called <em>Paging Area</em>. It is supposed to hold the Pagetables and Pagedirectories used by the CPU to abstract virtual memory. Since each table or directroy has a size of 4 KB, the whole Paging Area is divided into 4 KB frames and controlled y a simple bitmap-based memory manager.</li>
<li><code>0xEEE00000 - 0xFFFFFFFF</code>: The last part of the virtual address space is called <em>IO Memory</em>. Mappings for hardware-buffers (AHCI-buffers or the LFB) should be placed here. Every allocation made by the <code>IOMemoryManager</code> is 4 KB-aligned annd its size is a multiple of 4KB.</li>
</ul>
<p>TODO: Insert Memory Layout map here</p>
<h2><a class="anchor" aria-hidden="true" id="brief-description-of-the-different-memory-areas-and-their-memory-managers"></a><a href="#brief-description-of-the-different-memory-areas-and-their-memory-managers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Brief Description of the different memory areas and their memory managers</h2>
<p>All implementations of memory managers in <code>hhuOS</code> derive form one single class called <code>MemoryManager</code>. Simple as it is, it only contains the start- and end-address of the correspondong memory area and the status of the memory manager. With all implementations of memory managers deriving from this interface it is possible to inialize several instances of the same memory manager for different areas of memroy. One might ask why the usual methods <code>alloc</code> and <code>free</code> are not placed here as virtual functions to get a cleaner structure of derivation. But since the different memory managers have different requirements on parameters and return values for <code>alloc</code> and <code>free</code>, we decided against this idea.</p>
<h3><a class="anchor" aria-hidden="true" id="the-heap-memory-management"></a><a href="#the-heap-memory-management" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Heap Memory Management</h3>
<p>The <code>HeapMemoryManager</code> uses a simple list-based implementation to allocate and free memory blocks. Each memory block, regardless if allocated or free, has a header at the beginning of itself with the following structure:</p>
<pre><code class="hljs">struct Chunk{
    Chunk* prev<span class="hljs-comment">;</span>
    Chunk* next<span class="hljs-comment">;</span>
    <span class="hljs-keyword">bool </span>allocated<span class="hljs-comment">;</span>
    uint32_t size<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p>One may notice that a double linked list is used to iterate over the different memory blocks. This makes it easy to merge free neighbouring memory blocks with each other. Furthermore, every memory block, especially the allocated ones, have a header. There are implementations with a simple free list only, but we decided to use this solution since the memory consumption is not that much higher and it is easier to work with.
The <code>init</code>-function of this memory manager will set up the header of the first chunk right at the beginning of the memory block, which contains all the memory to be controlled by this memory manager. Right after that, a Spinlock is allocated.
If the memory manager receives an <code>alloc</code>-call, it will lock the list of memory headers at first and then start to loop over all headers to find a free memory block that fulfills the memory request. If there is no such memory block, the address <code>0</code> (nullpointer) will be returned. When a memory block is found, it is divided into two blocks if the size is larger than requested. At the end of the allocation the Spinlock is unlocked and the address right behind the header of the allocated memory block is returned.
The <code>free</code>-function will try to get the lock in first place and then set the <code>allocated</code>-entry in the header to <code>false</code>. Afterwards, it checks in loops if there are free neighbouring memory blocks and will merge them if possible. As a last step the freed memory will be unmapped by the Paging-system. It is important to remember that all headers of memory blocks must never be unmapped! If you do so, it may be mapped to a completely different physical address on the next access, not containing the needed information anymore.
There is one static instance of this <code>HeapMemoryManager</code> to controll the Kernelheap located at <code>0xC0400000</code>. All further instances of this memory manager - for example to manage the different Userspace-heaps - can be allocated on the Kernelheap using <code>new</code> Kernel-mode.
The operators <code>new</code> and <code>delete</code> are defined in <code>SystemManagement.cc</code>. They check whether the system is in Kernel- or Usermode and redirect the request to the corresponding memory manager.</p>
<h3><a class="anchor" aria-hidden="true" id="the-paging-area"></a><a href="#the-paging-area" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Paging Area</h3>
<p>The Paging Area, starting at <code>0xDF400000</code> is used to store all Pagedirectories and Pagetables used by the Paging system. Each Pagedirectory or Pagetable has a size of 4 KB. Therefore memory in this area is allocated and freed only in 4 KB chunks. To get track of all allocated and free 4 KB chunks, the memory manager uses a bitmap where one bit represents one 4 KB chunk. The whole bitmap is stored as an <code>uint32_t</code>-array. Allocations can be made fast using bitwise operations like rotations.</p>
<h3><a class="anchor" aria-hidden="true" id="the-io-memory"></a><a href="#the-io-memory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The IO Memory</h3>
<p>The IO Memory Area at the top of the address space is used to map buffers for hardware devices to virtual addresses. Since hardware buffers need an alignement in most cases, allocations of IO Memory are only made at addresses an with sizes which are a multiple of 4 KB. A 4 KB alignement fulfills the requirements of most hardware devices, so this is a very simple solution to the problem of allocating aligned memory. There are two types of mappings available: The first version of <code>mapIO</code> allocates some virtual memory in the IO Area and  - according to the allocation made in virtual memory - an amount of physical pages (using the <code>PageFramAllocator</code>). Then the virtual memory is mapped to these phyiscal addresses. This version should be used if ones needs a buffer for hardware at arbitrary physical addresses, for example for AHCI-devices. Note that the physical pages allocated by the <code>PageFrameAllocator</code> are not necessarily coherent. There is a special <code>mapIOPhysRange</code> function that tries to achieve this. The second version of <code>mapIO</code> needs a given physical address where the physical memory should be mapped to. This can be used if the hardware device has its own physical memory at own addresses like the Linear Frame Buffer. Please note, that the given physical address should never be within physical address space managed by the <code>Page FrameAllocator</code>, or otherwise there will be conflicts. Indeed this is very unlikely to happen since the available physical memory restricted in a way that there is enough space left to 4 GB for things like video memory.
The <code>IOMemoryManager</code> uses a free list to manage free memory blocks. There is one difficulty left, as there is no room left to store the size of allocated blocks: most memory managers using free lists store this information right at the beginning of the block, but this does not work here since it would break the 4 KB alignement. So the <code>IOMemoryManager</code> does not simply return one memory address, but a structure instead. This structure looks as following:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">IOMemInfo</span>{</span>
    <span class="hljs-keyword">uint32_t</span> virtStartAddress;  <span class="hljs-comment">// virtual start address of allocated memory</span>
    <span class="hljs-keyword">uint32_t</span> pageCount;         <span class="hljs-comment">// size of virtual area in pages</span>
    <span class="hljs-keyword">uint32_t</span>* physAddresses;    <span class="hljs-comment">// Array with physical addresses for the allocated pages</span>
};
</code></pre>
<p>This returned structure should be stored within the class that requests the IO memory, otherwise the memory block cannot be freed later. The returned <code>IOMemInfo</code> is also useful because it holds all addresses of physical pages the memory is mapped to. In many cases these physical addresses are needed by the hardware devices using the buffers, so the memory managers returns them directly to the requesting class.</p>
<h2><a class="anchor" aria-hidden="true" id="a-closer-look-at-the-implementation-of-the-paging-system"></a><a href="#a-closer-look-at-the-implementation-of-the-paging-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A closer look at the implementation of the paging system</h2>
<p>The Paging-system in hhuOS is used to abstract different virtual address spaces from the pyhsical memory. It consists of several classes controlled by the so called <code>SystemManager</code>, which acts as a central instance to manage requests for page-(un)mappings, address space switches and memory allocations.</p>
<h3><a class="anchor" aria-hidden="true" id="the-pageframeallocator"></a><a href="#the-pageframeallocator" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>PageFrameAllocator</code></h3>
<p>The <code>PageFrameAllocator</code> is the only instance in hhuOS that works with physical memory directly.
Its task is to keep track of mapped and non mapped page frames. The physical memory is divided
into 4 KB chunks, each of them called <em>page frame</em>. If a new page of virtual memory needs to
be mapped into physical memory, the <code>PageFrameAllocator</code> uses a simple bitmap mechanism
(the same as in the Paging area) and allocates a single 4 KB page frame in physical memory.
Afterwards, the start address of this page frame is returned.</p>
<h3><a class="anchor" aria-hidden="true" id="the-pagedirectory"></a><a href="#the-pagedirectory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>PageDirectory</code></h3>
<p>The class <code>PageDirectory</code> is the abstraction of the table called <em>Pagedirectory</em>. hhuOS uses
a two-level approach to realize memory virtualization through paging. So for each address
space there exists one Pagedirectory as a table with 1024 pointers (physical addresses) to Pagetables.
These Pagetables contain 1024 physical addresses (one for each 4 KB page). With this approach it is possible
to create virtual address spaces with <code>4 KB * 1024 * 1024 = 4 GB</code> of virtual memory for each Pagedirectory.
A given virtual 32-bit address is translated as follows: The first 10 bits of the address are
used as an index to an entry in the Pagedirectory-table. The next 10 bits of th address are used
as an index into the Pagetable, addressed by the entry in the directory. The entry in the Pagetable
then contains the physicals memory address of the 4 KB page the hardware should use. The remaining 12 bits
of the virtual address are the offset into the 4 KB page.
The abstracting class <code>PageDirectory</code> has three important private members that are used to realize the mapping.
The first is the virtual address of the Pagedirectory (the 4 KB table is placed in the Paging area as described above). This address is needed to manipulate or look up entries in the Pagedirectoy, since the physical address
would not be helpful here. The second is the physical address of the Pagedirectory, needed by the hardware (or more detailled: by the MMU of the CPU) to make address translations. This is the address that should be loaded to the CR3-register of x86-CPUs. The third is a pointer to a table containing all virtual addresses of the Pagetables addressed by the Pagedirectory. This point needs a bit of explanation: The x86-CPU only uses physical addresses to locate Pagedirctories and -tables. Using virtual addresses would not work here, since the tables are used to translate the virtual addresses into physical ones. But if hhuOS wants to look up entries in the Pagetables or manipulate them, it needs the virtual address of them - therefore we store those addresses in an extra table (which is also placed in th Paging area). The class <code>PageDirectory</code> offers functions to (un)map virtual addresses into the Pagedirectory or to get the corresponding physical address for a virtual address.
Note that there exist two constructors for this class: The first constructor does not take an argument and is only called once to initialize the Paging-system. It creates the <code>basePageDirectories</code> containing the Kernelspace-mappings. The second constructor is used to create the Pagedirectories for the several address spaces. It takes the <code>basePageDirectory</code> as an argument since the Kernelspace-mappings are used in every address space.</p>
<h3><a class="anchor" aria-hidden="true" id="what-about-the-basepagedirectory"></a><a href="#what-about-the-basepagedirectory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What about the <code>basePageDirectory</code>?</h3>
<p>The <code>basePageDirector</code> contains all mappings for the Kernelspace (everything above 3 GB). The Kernelspace is mapped into every address space. These mappings are identical for all address spaces, because we want the Kernel-data to be placed at the same addresses in every address space. This is realized by a simple construction: The last 256 entries of each Pagedirectory (addressing everything above 3 GB) created by the system point to 256 Pagetables right at the beginning of the Paging area. These 256 Pagetables map the Kernelspace and are created by the <code>basePageDirectory</code>. When a new Pagedirectory is created, these 256 addresses of Pagetables are copied from the <code>basePageDirectory</code> into the new directory so that the Kernel of hhuOS is mapped from the first step on.</p>
<h3><a class="anchor" aria-hidden="true" id="virtual-address-spaces"></a><a href="#virtual-address-spaces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Virtual Address Spaces</h3>
<p>A virtual address space is the next abstraction one level above the <code>PageDirectory</code>. Each address space contains one Pagedirectory, since it abstracts the virtual memory from the <em>real</em> physical memory. But additionally each address space has two <code>HeapMemoryManager</code>: One of those is the Kernelspace-heap memory manager, which exists once for the whole system (and all address spaces). The other one is individual for each address space and responsible for the Userspace-heap (which differs from address space to address space).</p>
<h3><a class="anchor" aria-hidden="true" id="the-systemmanagent"></a><a href="#the-systemmanagent" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The <code>SystemManagent</code></h3>
<p>The <code>SystemManagent</code> acts as a central instance in everything that has to do with memory management, Paging and address spaces. It keeps track of all available address spaces and is responsible for creating, switching and deleting them. In addition it is used as a wrapper for functions coming from the memory mangement or Paging system. Only those functions that should be directly accessible for the rest of the Kernel are exposed in the <code>SystemManagent</code>. So it offers functionality to map or unmap pages, to map or unmap memory for IO use (via the <code>IOMemoryManager</code>) and can calculate physical addresses for given virtual addresses.
Furthermore, the <code>SystemManagement</code> is registered as a faulthanlder for Pagefaults. Whenever a Pagefault occurs, the faulting address and the flags are passed to the <code>SystemManagement</code> and <code>trigger</code>is called to deal with the Pagefault. In order to answer memory requests, the <code>SystemManagement</code> holds the system state, i.e. whether the system is in Kernel- or Usermode. In the current state only Kernelmode is implemented, but the preparations the use of Kernel- and Usermode are built into the <code>SystemManagement</code> and the Pagins system already.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/doc_overview"><span class="arrow-prev">← </span><span>Overview</span></a><a class="docs-next button" href="/docs/bios_call"><span>Bios Call</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">Introduction</a></li><li><a href="#the-virtual-memory-layout-in-hhuos">The Virtual Memory Layout in hhuOS</a></li><li><a href="#brief-description-of-the-different-memory-areas-and-their-memory-managers">Brief Description of the different memory areas and their memory managers</a><ul class="toc-headings"><li><a href="#the-heap-memory-management">The Heap Memory Management</a></li><li><a href="#the-paging-area">The Paging Area</a></li><li><a href="#the-io-memory">The IO Memory</a></li></ul></li><li><a href="#a-closer-look-at-the-implementation-of-the-paging-system">A closer look at the implementation of the paging system</a><ul class="toc-headings"><li><a href="#the-pageframeallocator">The <code>PageFrameAllocator</code></a></li><li><a href="#the-pagedirectory">The <code>PageDirectory</code></a></li><li><a href="#what-about-the-basepagedirectory">What about the <code>basePageDirectory</code>?</a></li><li><a href="#virtual-address-spaces">Virtual Address Spaces</a></li><li><a href="#the-systemmanagent">The <code>SystemManagent</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logo_v3_dark.svg" alt="hhuOS" width="66"/></a><div><h5>Documetation</h5><a href="/docs/en/doc_overview.html">Overview</a></div><div><h5>Community</h5><a href="http://stackoverflow.com/questions/tagged/hhuOS" target="_blank">Stack Overflow</a><a href="http://hhuos.slack.com/">Project Chat on Slack</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/hhuos/hhuos">GitHub</a><a href="/developers.html">Team Members</a></div></section><section class="copyright">Copyright © 2017-2018 Burak Akguel, Christian Gesse, Fabian Ruhland, Filip Krakowski, Michael Schoettner</section></footer></div></body></html>