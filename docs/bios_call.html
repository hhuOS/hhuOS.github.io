<html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Bios Call · hhuOS</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Bios Call · hhuOS"/><meta property="og:type" content="website"/><meta property="og:url" content="https://hhuOS.github.io/index.html"/><meta property="og:description" content="## Overview"/><link rel="shortcut icon" href="/img/boot_logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://hhuOS.github.io/blog/atom.xml" title="hhuOS Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://hhuOS.github.io/blog/feed.xml" title="hhuOS Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible doc"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/logo.png"/><h2 class="headerTitle">hhuOS</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/doc_overview.html" target="_self">Docs</a></li><li class=""><a href="/docs/TODOs.html" target="_self">ToDo&#x27;s</a></li><li class=""><a href="/en/help.html" target="_self">Help</a></li><li class=""><a href="/blog" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Memory Managment and Paing</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Overview</h3><ul><li class="navListItem"><a class="navItem" href="/docs/doc_overview.html">Overview</a></li></ul></div><div class="navGroup navGroupActive"><h3>Memory Managment and Paing</h3><ul><li class="navListItem"><a class="navItem" href="/docs/paging_mm.html">Memory and Paging</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/bios_call.html">Bios Call</a></li></ul></div><div class="navGroup navGroupActive"><h3>Processes and Threads</h3><ul><li class="navListItem"><a class="navItem" href="/docs/process_thread_overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/scheduler.html">Scheduler</a></li><li class="navListItem"><a class="navItem" href="/docs/process.html">Process</a></li><li class="navListItem"><a class="navItem" href="/docs/thread.html">Thread</a></li></ul></div><div class="navGroup navGroupActive"><h3>Filesystem</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fs_overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fat.html">FAT</a></li><li class="navListItem"><a class="navItem" href="/docs/vfs.html">VFS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Components</h3><ul><li class="navListItem"><a class="navItem" href="/docs/modules.html">Modules</a></li></ul></div><div class="navGroup navGroupActive"><h3>GUI</h3><ul><li class="navListItem"><a class="navItem" href="/docs/gui_overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/vesa.html">VESA</a></li><li class="navListItem"><a class="navItem" href="/docs/color.html">Color</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Bios Call</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h2>
<p>hhuOS provides the possibility to invoke BIOS-calls since they are used to determine the amount of usable physical memory and to set up VESA graphic modes. Due to the fact that hhuOS runs in protected mode using Paging as a memory abstraction, some work is included to switch into realmode for a BIOS-call.
Everything that has to do with BIOS-calls is encapsulated in one static class called <code>BIOS</code> and some assembler code contained in <code>interrupt.asm</code>. Additionally, a seperate segment is set up in the GDT for address <code>0x24000</code>. This is the segment that is used during the BIOS-call.</p>
<h2><a class="anchor" aria-hidden="true" id="initializing-for-bios-calls"></a><a href="#initializing-for-bios-calls" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Initializing for BIOS-calls</h2>
<p>The initialization of the BIOS-call segment at <code>0x24000</code> is somewhat tricky:
The whole code that is used to invoke the BIOS-call is written manually into this segment. This is done by <code>BIOS::init()</code>. Later, the code jumps into this segment to execute the code.</p>
<h2><a class="anchor" aria-hidden="true" id="detailed-description-of-a-bios-call"></a><a href="#detailed-description-of-a-bios-call" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Detailed description of a BIOS-call</h2>
<p>Invoking a BIOS-call starts a complex mechanism in hhuOS, since paging and the protected mode have to be disabled.
Here we describe the different steps that are done to invoke a BIOS-call:</p>
<ol>
<li>Write the parameters for the BIOS-call to <code>0x26000</code>, right behind the 16-bit code. This can be done with paging enabled, because the BIOS-call segment at <code>0x24000</code> is simply mapped to <code>0xC0024000</code>.</li>
<li>Call <code>BIOS::Int(number)</code> with the number of the BIOS-call to invoke. Up to this step the application requesting the BIOS-call is responsible for everything. After calling <code>Int()</code>, control is handed to the BIOS-call class in hhuOS and the following steps are done by the system.</li>
<li>The BIOS-call number is wirtten at the right place into the BIOS-call segment manually. This might be <em>quick and dirty</em>, but it works.</li>
<li>All interrupts are disabled, so that the BIOS-call can be executed completely.</li>
<li><code>bios_call</code> - implemented in <code>interrupt.asm</code> - is invoked.</li>
<li>First thing the assembler code does is loading the IDT for 16-bit code. Afterwards, the important registers are saved on the current stack.</li>
<li>Since we must disable paging in a later step, we have to make sure to be able to get the physical address of the stack. To ensure this, the code switches to the initial kernel stack that is used to set up the system. This stack is placed between <code>0xC0100000</code> and <code>0xC0400000</code> and the physical address can be calculated by subtracting <code>0xC0000000</code> (see following step). If the system is currently setting up, no stack switch is needed since the initial kernel stack is already in use. If the scheduling system is active, every thread uses its own stack and the old inital kernel stack is reused as a stack for BIOS-calls.</li>
<li>The address of the active Pagedirectory (CR3-register) is pushed onto the stack and a special Pagedirectory, only for BIOS-calls, is loaded. This directory maps the virtual addresses <code>0xC0000000 - 0xC0400000</code> to the physical addresses <code>0x0 - 0x400000</code>. The advantage is that we are now able to calculate all relevant phyiscal addresses by subtracting <code>0xC0000000</code> from the virtual addresses.</li>
<li>The code jumps to the next instruction, but subtracts <code>0xC0000000</code> from the instrcution address. Since the Kernel code is placed between <code>0xC0100000</code> and <code>0xC0400000</code> and the special Pagedirectory is loaded, subtracting <code>0xC0000000</code> from the next instruction-address results in using the physical addresses for instructions now.</li>
<li>The EIP now uses phyiscal addresses, so the paging can be disabled and a special GDT, in which the BIOS-call segment is defined, is loaded by its physical address. Additionally, some registers are set to the physical address values since paging is disabled.</li>
<li>Via <code>call 0x18:0</code> the system jumps to the special code segment that is placed at <code>0x240000</code> and prepared in <code>BIOS::init()</code>. Now the BIOS-call is executed.</li>
<li>After returning from the BIOS-call, the old state is restored in reversed order: So at first Paging with the BIOS-call Pagedirectory is enabled, the code jumps to the high addresses of Kernel code, the old stack is restored and the old Pagedirectory is loaded again.</li>
<li>The code returns to <code>BIOS::Int</code>. The return-value of the BIOS-call is available at <code>0xC9F000</code>.</li>
</ol>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="paging_mm.html">← Memory and Paging</a><a class="docs-next button" href="process_thread_overview.html">Overview →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/logo.png" alt="hhuOS" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/doc_overview.html">Getting Started with the Documentation</a></div><div><h5>Community</h5><a href="http://stackoverflow.com/questions/tagged/" target="_blank">Stack Overflow</a><a href="http://hhuos.slack.com/">Project Chat on Slack</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/hhuos/hhuos">GitHub</a><a href="/developers.html">Developer Showcase</a></div></section><section class="copyright">Copyright © 2018 Burak Akguel, Christian Gesse, Fabian Ruhland, Filip Krakowski, Michael Schoettner</section></footer></div></body></html>